# 关于
本节介绍在启用虚拟内存、内核跳转到高端地址时，内核镜像的生成。

重新定义了链接脚本。

定义了多个目标：cxx_macros.h生成文件，用于生成C++宏
 [并增加了settings:`"${workspace_loc:/${ProjName}/Debug/cxx_macros.h}"`]-->已经证明不能正常工作，因为
 cxx_macros.h文件没有正常地被依赖。
 将所有的宏定义移动到了makefile中
 
现在实际上重新架构了整个内核生成系统。
内核的大小是动态的，但是源代码中却需要内核大小的信息，
因此需要两遍生成。我们使用size\_old和size\_new来记录
两次生成内核的大小，如果无差异就说明生成正确了。

现在,cxx_macros.h被放到了include/arch/...下，使得其不必再影响所有的类了。

shared目录包含所有工程需要的文件
# 测试程序
在`init_mmu_enabled`函数中，我们首先重新初始化了VirtualManager，然后立即禁用
TTBR0的转换，意味着从此刻开始，内核只会使用高端地址。
然后我们进行了从PART1到PART2一些必要的转换动作，重新初始化设备的地址。

# 状态
已完成

树莓派：测试未通过,测试不通过的原因是内核起始地址0，就最简单的能够在树莓派上工作的工程
1\_3而言，如果将其中的地址改成0，也不能正常运行。尚不知为何。推测是GPU需要加载某些数据，
覆盖了内核的某些部分。对于QEMU而言，没有覆盖的问题。
          改成0x80000后，测试通过。

# 草稿
确定内核PART1和PART2两个部分，PART1最先加载在低端部分，PART2加载在高端部分。

内核镜像为output.bin, 该镜像文件分为两个部分： PART2在首部，PART1在尾部。
为什么这样安排呢？因为PART1在跳转到PART2之后，实际上就没用了。
PART1是可以丢弃的，并且代码仅仅用于加载PART2。因此，PART1实际上可以做得非常小，
可以只包含必要的启动代码。